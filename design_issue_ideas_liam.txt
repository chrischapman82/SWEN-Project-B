Design Issues:
1. MailGenerator should not be directly putting mail into the mail into the pool via the step function; instead, 
it should implement two functions: “initPieces”, “popNextPiece” and “isFinished” which are used as implied, from 
an interface “ImailGenerator”. Simulation can then run by taking responsibility of the task of getting the next
 piece of mail from the generator, and putting it into the MailPool. The current design is bad because: a) ImailPool
 and MailGenerator are highly coupled, b) there is a high representational gap with the mail generator doing anything
 but generating (i.e. constructing) mail items, and b) it does not make sense to assign responsibility of mail 
allocation to the generator because the generator should only be responsible constructing mail items as it has 
the initializing data to do so but is not relevant for any other part of the system, d) it restruct extendibility
 to more complex systems – such as having one generator and multiple mail pools.

2. PiorityMailItem should not be a seperate class extended from MailItem. Instead, MailItem should have an attribute
 “Piority”, which if set to 0 implies it is not a priority item at all, and if a positive number it is (that number
 then being its priority level). The existing design is poor because it is requires unnecessary type checking and 
casting. <Not sure how to justify with GRASP principles>. This would require various refactorings such as 
IrobotBehaviour’s “priorityArrival” simply being “newArrival”.

3. There should be no “Building” static class per say; these attributes are used for simulation purposes and so
 instead should be loaded from disk at runtime by a parameters loader class (pure fabrication) which is called 
by simluation. This would improve cohesion between classes, and better assign reposnsibilities to the class 
that uses the information.

4. There should be a “stepable” interface (or similar) which every class steping should interface. This would 
create higher cohesion and better abstraction. In particular the simulation class is currently accessing the
 robot variables of automail and stepping them individually, when it should be able to call a “stepAll” function 
for better delegation and abstraction. Clock would also be stepable – i.e. one step = 1 tick

5. Simulation should not be solely implemented in the main function. Instead it should be moved to a seperate 
function which does the exact same thing as the current main function but also returns the delivery score. Main 
can then use this function, and if the programmer desires they may run many simulations on many seeds, with or 
without debug output and return the total seed to get a more accurate statistical indication of the performance 
of the strategies used. This relates to appropriate delegation and cohesion.



***** CHRIS *****
What I've added so far

Polymorphism for the Robot class.
    Created StrongRobot, BigRobot, WeakRobot which all inherit from robot.
    Each are in charge of their initialisation.

Created helper function in Automail -> createRobot(IMailDelivery delivery, IMailPool mailPool, String robotType)
     Returns a robot based off of given robotType
     +   More flexible
         Reduces repeat code
         Easier to understand


Changed robot1 and robot2 in Automail to ArrayList<Robot>
    More flexible - allows for easier changes in the numbers of robots used
    
    Changed robot1, robot2 in simulation to (for robot : robots)
        However, privacy here remained poor
         

Removed behaviour as input for robot and added initialiser to robot
    Robot already contained all the information to create behaviour
    Better encapsulation
