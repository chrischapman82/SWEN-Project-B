// the 1500 word part of the assignment. to be exported as pdf and included in the final submission

Design Criticisms:


1. In the provided package, Robot differentiates between different types of robots with the strong attribute. While it works reasonably well for a system with two robot types, it makes extension and modification of types of robots difficult. We proprosed using polymorphism, creating the classes RobotBig, RobotWeak and RobotStrong which inherit robot. This reduces complexity and reuse of code, allowing simpler comparisons through comparing class types, which scales much better with additioinal types of robots. Also leads to better delegation, where subclasses are in charge of their own creation, containing information such as the strength of the robot and tube size for robot creation. Furthermore, this alternative allows for the addition of another robot type to be simpler and would follow the open-closed principle. For example, if we were to add a new type of robot, a weak robot that can carry 6 items, the suggested system would be closed to modifications, requiring no changes to robot, and open to extension, creating a new subclass of robot to implement the new requirements.


2. MailGenerator contains a pointer to MailPool, which reduces cohesion and increases the representational gap for how the system 
should intuitively work. MailGenerator should intuitively do one thing: generate mail. The provided package requires simulation to 
call a method in MailGenerator to directly add the mail to MailPool and call the AddToPool method. This reduces cohesion because it 
gives MailGenerator a responsibility it should not. Our solution to this is to de-couple MailGenerator and MailPool so that 
MailGenerator only generates a HashMap of mail. Our system then employs the Simulation class  to provide indirection by generating 
the time ordered mail set from MailGenerator and adding mail to MailPool Automail. This system reduces coupling because and allows 
for greater potnetial extendibility; for instance if we wanted a variable number of MailGenerators and MailPools we could do so.


3. In the existing package, Simulation directly notifies each inidividual robot of a new priority arrival. This is poor cohesion 
for the following reasons: Simulation should be about stepping the main system components through in time order fashion and 
recording the results. Each robot is a member of an Automail System which has robots and a mail-pool, and it is the responsibility 
of the mail pool to notify robots of new arrivals, fill their storage tubes etc. It also has high coupling because it means if we 
want to add more robots we need to update the simulation code. Our solution fixes this by using a function within Automail which 
notifies all robots of priority arriavls, regardless of how many there are. We decided to put this function in Automail, because 
Automail is the system which agregates robots and the MailPool. Therefore simulation only calls one function, addIncomingMail, and 
autommail notifies robots of priority items and adds mail to mailPool.



In the initial design, IMailPool only works for one configuration of robots, in the given case, weak and strong. This implementation has very poor extendibility, where having a different set of robots requires creating a new <Robot1><Robot2>MailPool implementation of mail pool. This is due to the high coupling between MailPool, robot and automail, where MailPool is required to create robot, and robot information is required to create different MailPools. Our solution implements indirection via a new interface (following the strategies pattern) IMasterPool. IMasterPool controls and maintains the mail pools, distributing mail based on mailItem information and coupling robots with their mailpool. This results in more flexbile code, where IMailPool can be used for different sets of robots. This also leads to better encapsulation, where robots will only interact with a corresponding mailPool and avoids the previous requirement of giving robot information (such as isStrong) to the pool. 



-----------------------------------------------------------
other changes that were made:

Added createRobot method to automail which takes a robot type tag to create a robot. Reduces repeat code during robot creation. Also clearer, using definitive robot name tags rather than boolean is strong.

Changed robot1 and robot2 to list of robots. Allows for greater flexibility, being able to take input of more than just the required 2 robots.

Many variables are hard coded and are not easily modified by users without access to the source code. To allow users to change the simulation as they see fit we can use a test file in which they can customise the sim. Therefore we created a PropertiesLoader class. Since variables are private and there are only getters, it is immutable and since 
everything is static it can be acccessed everywhere without instantiation. 
Removed whatever method arguments/variables that are given by Properties as they can be accessed directly now. Removing arguments is decreasing coupling between method caller and method executer. But, executer now is coupled with propertiesloader class since they depend on it having the variable needed. If we are to have a customisable properties file this is unavoidable as we will always need to read the data from elswewhere rather than haaving it hard coded into the relevant class.

ReportDelivery static class in simulation removed, now is static method instead. Reduces arguments passed into automail into robot. Locks us into having one simulation running at a time only but this should be acceptable as reading from the properties file does not support multiple simulations anyway. Removal of interface reduces protection against variation but its minor because the simulation class should be stable compared to strategies where most of the changes are expected to take place. (since the whole system is a simulation for testing various strategies)




